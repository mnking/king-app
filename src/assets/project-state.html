<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project State</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f8fafc;
        --card: #ffffff;
        --border: #e5e7eb;
        --text: #0f172a;
        --muted: #6b7280;
        --pill: #e2e8f0;
        --pill-text: #334155;
        --green: #10b981;
        --blue: #2563eb;
        --amber: #f59e0b;
        --red: #ef4444;
      }
      * { box-sizing: border-box; }
      body { margin: 0; padding: 24px; font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif; background: var(--bg); color: var(--text); }
      h1 { margin: 0 0 8px; font-size: 28px; letter-spacing: -0.01em; }
      p { margin: 0; color: var(--muted); }
      a { color: var(--blue); }
      .page { max-width: 1180px; margin: 0 auto; display: flex; flex-direction: column; gap: 12px; }
      .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 8px; }
      .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06); }
      .card h3 { margin: 0; font-size: 13px; color: var(--muted); font-weight: 600; text-transform: uppercase; letter-spacing: 0.02em; }
      .card .value { font-size: 22px; font-weight: 700; margin-top: 6px; }
      .lang-toggle { display: inline-flex; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; margin-left: 8px; }
      .lang-toggle button { border: none; background: transparent; padding: 6px 10px; font-weight: 600; color: var(--muted); cursor: pointer; }
      .lang-toggle button.active { background: #2563eb; color: #fff; }
      .muted { color: var(--muted); }
      .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
      .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
      .section { margin-top: 8px; }
      .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; background: var(--pill); color: var(--pill-text); font-size: 12px; font-weight: 600; text-transform: capitalize; }
      .pill .dot { width: 8px; height: 8px; border-radius: 50%; }
      .table { width: 100%; border-collapse: collapse; margin-top: 4px; }
      .table th, .table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border); }
      .table th { font-size: 12px; text-transform: uppercase; letter-spacing: 0.02em; color: var(--muted); }
      .table td { font-size: 14px; vertical-align: middle; }
      .progress-track { width: 100%; height: 8px; border-radius: 999px; background: #e2e8f0; overflow: hidden; }
      .progress-bar { height: 100%; width: 0%; background: var(--blue); border-radius: 999px; transition: width 200ms ease; }
      .col-eta { display: none; }
      .col-milestone { display: none; }
      .status-not-started { background: var(--pill); color: var(--pill-text); }
      .status-in-progress { background: rgba(37, 99, 235, 0.1); color: var(--blue); }
      .status-blocked { background: rgba(239, 68, 68, 0.1); color: var(--red); }
      .status-done { background: rgba(16, 185, 129, 0.12); color: var(--green); }
      .status-not-started .dot { background: var(--pill-text); }
      .status-in-progress .dot { background: var(--blue); }
      .status-blocked .dot { background: var(--red); }
      .status-done .dot { background: var(--green); }
      .legend { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 6px; }
      .legend-item { font-size: 12px; display: inline-flex; align-items: center; gap: 6px; padding: 6px 8px; border-radius: 8px; border: 1px dashed var(--border); background: rgba(226, 232, 240, 0.6); }
      .error { color: var(--red); font-weight: 600; }
      .treemap { display: flex; flex-direction: column; gap: 2px; padding: 8px; border: 1px solid var(--border); border-radius: 12px; background: #f1f5f9; overflow: hidden; width: 100%; aspect-ratio: 1 / 1; min-height: 340px; }
      .treemap-row { display: flex; gap: 2px; width: 100%; }
      .treemap-item { position: relative; background: #e2e8f0; border-radius: 8px; padding: 10px; height: 100%; color: var(--text); display: flex; flex-direction: column; justify-content: space-between; box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.06); overflow: hidden; }
      .treemap-item h4 { margin: 0; font-size: 14px; line-height: 1.2; }
      .treemap-item .meta { font-size: 12px; color: var(--muted); }
      .treemap-bar { position: absolute; bottom: 0; left: 0; height: 6px; border-radius: 0 0 12px 12px; background: var(--blue); width: 0; transition: width 200ms ease; }
      .treemap-legend { font-size: 12px; color: var(--muted); margin-top: 4px; }
      #piechart { padding: 18px; min-height: 300px; }
      #piechart svg { max-width: 100%; max-height: 100%; }
      .editor { margin-top: 12px; border: 1px dashed var(--border); border-radius: 12px; padding: 12px; background: #f8fafc; }
      .editor h3 { margin: 0 0 8px; }
      .editor-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
      .editor-card { border: 1px solid #c7d2fe; border-radius: 10px; padding: 10px; background: #eef2ff; display: flex; flex-direction: column; gap: 8px; }
      .editor-card label { font-size: 12px; font-weight: 600; color: var(--muted); display: block; margin-bottom: 2px; }
      .editor-card input, .editor-card select, .editor-card textarea { width: 100%; padding: 6px 8px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; }
      .editor-card textarea { resize: vertical; min-height: 60px; }
      .editor-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
      .btn { border: 1px solid var(--border); background: #fff; border-radius: 8px; padding: 8px 12px; font-weight: 600; cursor: pointer; }
      .btn.primary { background: #2563eb; color: #fff; border-color: #1d4ed8; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .small { font-size: 12px; color: var(--muted); }
      .move-buttons { display: inline-flex; gap: 6px; }
      .icon-btn { border: 1px solid var(--border); background: #f8fafc; border-radius: 8px; padding: 6px 8px; cursor: pointer; font-weight: 600; }
      .icon-btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .feature-milestones { display: flex; flex-wrap: wrap; gap: 6px 10px; }
      .feature-milestones label { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: var(--text); font-weight: 600; border: 1px solid #bfdbfe; border-radius: 10px; padding: 8px 10px; background: #e0f2fe; }
      .tabs { display: inline-flex; gap: 6px; padding: 4px; border: 1px solid var(--border); border-radius: 10px; background: #fff; }
      .tab-btn { border: none; background: transparent; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-weight: 700; color: var(--muted); }
      .tab-btn.active { background: #2563eb; color: #fff; }
      @media (max-width: 640px) {
        body { padding: 16px; }
        .row { align-items: flex-start; flex-direction: column; }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <div class="row" style="gap: 12px; align-items: center; flex-wrap: wrap;">
          <h1 id="title-main">Project State</h1>
          <div class="lang-toggle" aria-label="Language toggle">
            <button type="button" id="btn-lang-en" class="active" data-lang="en">EN</button>
            <button type="button" id="btn-lang-vi" data-lang="vi">VI</button>
          </div>
        </div>
      </header>

      <div class="card section">
        <div class="row">
          <h3 id="milestones-title">Milestones</h3>
          <span class="muted" id="milestones-sub">Weighted by feature sizes</span>
        </div>
        <div id="milestones" class="grid"></div>
      </div>

      <div id="summary" class="cards" aria-live="polite"></div>

      <div class="card section">
        <div class="row" style="gap: 12px; flex-wrap: wrap;">
          <div class="row" style="gap: 12px;">
            <h3 id="features-title">Features</h3>
            <span id="last-updated" class="muted"></span>
          </div>
          <div id="data-tabs" class="tabs" role="tablist" aria-label="Data view"></div>
        </div>
        <div>
          <table class="table" aria-label="Feature progress table">
            <thead>
              <tr>
                <th id="th-feature">Feature</th>
                <th id="th-milestone" class="col-milestone">Milestone</th>
                <th id="th-milestone-progress-1">Milestone progress</th>
                <th id="th-milestone-progress-2">Milestone progress</th>
                <th id="th-status">Status</th>
                <th id="th-size">Size</th>
                <th style="width: 200px;" id="th-progress">Progress</th>
                <th id="th-eta" class="col-eta">ETA</th>
              </tr>
            </thead>
            <tbody id="feature-rows"></tbody>
          </table>
        </div>
      </div>

      <div class="card section">
        <div class="row" style="gap: 12px; align-items: center;">
          <h3 style="margin: 0;" id="piechart-title">Status Distribution</h3>
          <span class="muted" id="piechart-sub">Weighted by feature size</span>
        </div>
        <div id="piechart" class="treemap" aria-label="Feature pie chart"></div>
      </div>

      <div class="card section">
        <div class="row" style="gap: 12px; align-items: center;">
          <h3 style="margin: 0;" id="treemap-title">Treemap</h3>
          <span class="muted" id="treemap-sub">Sized by size weight; color by status; bar shows progress.</span>
        </div>
        <div id="treemap" class="treemap" aria-label="Feature treemap"></div>
      </div>

      <div class="card section">
        <h3 id="legend-title">Legend</h3>
        <div id="legend" class="legend"></div>
      </div>

      <div class="card section">
        <div class="row" style="gap: 12px; align-items: center; flex-wrap: wrap;">
          <div class="row" style="gap: 12px; align-items: center;">
            <h3 style="margin: 0;" id="inline-title">Inline Editor</h3>
            <span class="muted" id="inline-note">Modify values, upload/download JSON, or reset.</span>
          </div>
          <div class="editor-actions">
            <button type="button" class="btn primary" id="btn-edit">Edit data</button>
            <button type="button" class="btn" id="btn-close-edit" disabled>Close</button>
            <button type="button" class="btn" id="btn-download" disabled>Download JSON</button>
            <button type="button" class="btn" id="btn-upload">Upload JSON</button>
            <button type="button" class="btn" id="btn-reset" disabled>Reset</button>
            <input type="file" id="file-input" accept="application/json" hidden />
          </div>
          <span class="small" id="inline-footnote">Edits are client-side only; download JSON to persist.</span>
        </div>
        <div id="editor" class="editor" hidden>
          <div class="editor-grid" id="editor-grid"></div>
        </div>
      </div>

      <div id="error" role="alert" class="error"></div>
    </div>

    <script>
      let stateData = null;
      let originalData = null;
      let editing = false;
      let currentLanguage = 'en';
      const STORAGE_KEY = "project-state-data";
      let viewFilter = "all";

      const translations = {
        en: {
          title: "Project State",
          milestonesTitle: "Milestones",
          milestonesSub: "Weighted by feature sizes",
          summaryCompletion: "Completion (weighted)",
          summaryDone: "Features done",
          summaryBlocked: "Blocked",
          featuresTitle: "Features",
          treemapTitle: "Treemap",
          treemapSub: "Sized by size weight; color by status; bar shows progress.",
          legendTitle: "Legend",
          inlineTitle: "Inline Editor",
          inlineNote: "Modify values, upload/download JSON, or reset.",
          inlineFootnote: "Edits are client-side only; download JSON to persist.",
          buttons: {
            edit: "Edit data",
            close: "Close",
            download: "Download JSON",
            upload: "Upload JSON",
            reset: "Reset"
          },
          columns: {
            feature: "Feature",
            milestone: "Milestone",
            milestoneProgress1: "Milestone progress",
            milestoneProgress2: "Milestone progress",
            status: "Overall Status",
            size: "Size",
            progress: "Progress",
            eta: "ETA"
          },
          treemapLegend: "Sized by size weight; color by status; bar shows progress.",
          piechartTitle: "Status Distribution",
          piechartSub: "Weighted by feature size",
          progressLabel: "Progress"
        },
        vi: {
          title: "Trạng thái dự án",
          milestonesTitle: "Mốc",
          milestonesSub: "Tính trọng số theo độ lớn",
          summaryCompletion: "Hoàn thành (trọng số)",
          summaryDone: "Tính năng xong",
          summaryBlocked: "Bị chặn",
          featuresTitle: "Tính năng",
          treemapTitle: "Sơ đồ treemap",
          treemapSub: "Diện tích theo độ lớn; màu theo trạng thái; thanh hiển thị tiến độ.",
          legendTitle: "Chú giải",
          inlineTitle: "Chỉnh sửa trực tiếp",
          inlineNote: "Chỉnh sửa, tải lên/tải xuống JSON.",
          inlineFootnote: "Chỉnh sửa chạy trên trình duyệt; tải JSON để lưu.",
          buttons: {
            edit: "Chỉnh sửa",
            close: "Đóng",
            download: "Tải JSON",
            upload: "Tải lên JSON",
            reset: "Đặt lại"
          },
          columns: {
            feature: "Tính năng",
            milestone: "Mốc",
            milestoneProgress1: "Tiến độ theo mốc",
            milestoneProgress2: "Tiến độ theo mốc",
            status: "Trạng thái tổng",
            size: "Độ lớn",
            progress: "Tiến độ",
            eta: "Hạn"
          },
          treemapLegend: "Độ rộng dựa vào độ lớn; màu theo trạng thái; thanh hiển thị tiến độ.",
          piechartTitle: "Phân bố trạng thái",
          piechartSub: "Tính trọng số theo độ lớn",
          progressLabel: "Tiến độ"
        }
      };

      async function loadState() {
        try {
          const injectedState = window.__PROJECT_STATE__ || null;
          if (!injectedState) {
            throw new Error("Project state data unavailable");
          }
          const data = JSON.parse(JSON.stringify(injectedState));
          originalData = JSON.parse(JSON.stringify(data));
          const cached = loadCachedState();
          stateData = cached || JSON.parse(JSON.stringify(data));
          ensureMilestoneAllocations(stateData);
          removeLegacyFields(stateData);
          setLanguage(currentLanguage, false);
          render(stateData);
          setupActions();
        } catch (err) {
          const cached = loadCachedState();
          if (cached) {
            stateData = cached;
            originalData = JSON.parse(JSON.stringify(cached));
            ensureMilestoneAllocations(stateData);
            removeLegacyFields(stateData);
            setLanguage(currentLanguage, false);
            render(stateData);
            setupActions();
            document.getElementById("error").textContent = "Loaded from local cache; project state data unavailable.";
          } else {
            document.getElementById("error").textContent = err.message;
          }
        }
      }

      const weightForSize = (size, defs) => {
        if (!defs) return 1;
        return defs[size] || 1;
      };

      function getMilestonePercent(feature, milestoneName) {
        const alloc = feature?.milestoneAllocations || {};
        const val = Number(alloc[milestoneName]);
        if (Number.isFinite(val)) return Math.max(0, Math.min(100, val));
        return 100;
      }

      function getMilestonePercent(feature, milestoneName) {
        const alloc = feature?.milestoneAllocations || {};
        const val = Number(alloc[milestoneName]);
        if (Number.isFinite(val)) return Math.max(0, Math.min(100, val));
        return 100;
      }

      function markDirty() {
        stateData.lastUpdated = new Date().toISOString();
        document.getElementById("btn-download").disabled = false;
        document.getElementById("btn-reset").disabled = false;
        saveLocalState(stateData);
      }

      function renderSummary(data) {
        const defs = data.sizeDefinitions || {};
        const totalFeatures = data.features?.length || 0;
        const blocked = data.features?.filter((f) => f.status === "blocked").length || 0;

        let weightedTotal = 0;
        let weightedDone = 0;
        let unweightedDone = 0;
        (data.features || []).forEach((f) => {
          const w = weightForSize(f.size, defs);
          weightedTotal += w;
          weightedDone += w * (f.progress || 0);
          if ((f.progress || 0) >= 1) unweightedDone += 1;
        });

        const weightedPct = weightedTotal ? (weightedDone / weightedTotal) * 100 : 0;

        const cards = [
          { label: t("summaryCompletion"), value: `${weightedPct.toFixed(1)}%` },
          { label: t("summaryDone"), value: `${unweightedDone} / ${totalFeatures}` },
          { label: t("summaryBlocked"), value: blocked }
        ];

        const container = document.getElementById("summary");
        container.innerHTML = "";
        cards.forEach((card) => {
          const el = document.createElement("div");
          el.className = "card";
          el.innerHTML = `<h3>${card.label}</h3><div class="value">${card.value}</div>`;
          container.appendChild(el);
        });
      }

      function updateMilestoneProgressHeaders(milestones) {
        const first = milestones?.[0]?.name || t("columns")["milestoneProgress1"];
        const second = milestones?.[1]?.name || t("columns")["milestoneProgress2"];
        const h1 = document.getElementById("th-milestone-progress-1");
        const h2 = document.getElementById("th-milestone-progress-2");
        if (h1) h1.textContent = first;
        if (h2) h2.textContent = second;
      }

      function renderTabs(data) {
        const tabs = document.getElementById("data-tabs");
        if (!tabs) return;
        const options = ["all", ...(data.milestones || []).map((m) => m.name)];
        const prev = viewFilter;
        tabs.innerHTML = options
          .map((opt) => `<button class="tab-btn ${opt === viewFilter ? "active" : ""}" data-tab="${opt}" role="tab" aria-selected="${opt === viewFilter}">${opt === "all" ? "Overall" : opt}</button>`)
          .join("");
        const next = options.includes(prev) ? prev : "all";
        viewFilter = next;
        tabs.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.onclick = () => {
            viewFilter = btn.getAttribute("data-tab") || "all";
            render(stateData);
          };
        });
      }

      function renderFeaturesTable(data) {
        const body = document.getElementById("feature-rows");
        body.innerHTML = "";
        const defs = data.sizeDefinitions || {};
        const formatter = new Intl.NumberFormat(undefined, { style: "percent", minimumFractionDigits: 0, maximumFractionDigits: 0 });
        const milestoneSlots = (data.milestones || []).slice(0, 2);
        const filteredMilestone = viewFilter !== "all" ? (data.milestones || []).find((m) => m.name === viewFilter) : null;
        const allowed = filteredMilestone ? new Set(filteredMilestone.featuresIncluded || []) : null;

        (data.features || []).forEach((f) => {
          if (allowed && !allowed.has(f.id)) return;
          const tr = document.createElement("tr");
          const progress = Math.max(0, Math.min(1, f.progress || 0));
          const milestoneCells = milestoneSlots.map((m) => {
            const included = (m.featuresIncluded || []).includes(f.id);
            if (!included) return "\u2014";
            if (viewFilter !== "all" && viewFilter !== m.name) return "\u2014";
            const allocPct = getMilestonePercent(f, m.name);
            const factor = allocPct / 100;
            const normalized = factor > 0 ? Math.min(1, progress / factor) : 0;
            const displayPct = Math.round(normalized * 100);
            const label = displayPct >= 100 ? "done" : `${displayPct}%`;
            const pillClass =
              normalized >= 1
                ? "status-done"
                : normalized === 0
                  ? "status-not-started"
                  : "status-in-progress";
            return `<span class="pill ${pillClass}" style="font-size:11px;">${label}</span>`;
          });
          tr.innerHTML = `
            <td>
              <div>${localize(f, "name") || f.id}</div>
              <div class="muted" style="font-size: 12px;">${localize(f, "notes") || ""}</div>
            </td>
            <td class="col-milestone">${milestoneLabel(f.id, data.milestones)}</td>
            <td>${milestoneCells[0] || "\u2014"}</td>
            <td>${milestoneCells[1] || "\u2014"}</td>
            <td>${renderStatusPill(f.status)}</td>
            <td>${f.size || "-"}</td>
            <td>
              <div class="progress-track" aria-label="Progress for ${f.name}">
                <div class="progress-bar" style="width:${progress * 100}%"></div>
              </div>
              <div class="muted" style="font-size: 12px;">${formatter.format(progress)} (${weightForSize(f.size, defs)} pts)</div>
            </td>
            <td class="col-eta">${f.eta || "\u2014"}</td>
          `;
          body.appendChild(tr);
        });

        const updated = data.lastUpdated ? new Date(data.lastUpdated).toLocaleString() : "";
        document.getElementById("last-updated").textContent = updated ? `Updated ${updated}` : "";
      }

      function renderTreemap(data) {
        const container = document.getElementById("treemap");
        container.innerHTML = "";

        const defs = data.sizeDefinitions || {};
        let items = (data.features || []).map((f) => ({
          ...f,
          weight: weightForSize(f.size, defs),
        }));
        const milestone = viewFilter !== "all" ? (data.milestones || []).find((m) => m.name === viewFilter) : null;
        if (milestone) {
          const allowed = new Set(milestone?.featuresIncluded || []);
          items = items.filter((f) => allowed.has(f.id));
        }
        if (!items.length) return;

        const totalWeight = items.reduce((acc, f) => acc + f.weight, 0) || 1;
        const targetRows = Math.max(1, Math.round(Math.sqrt(items.length)));
        const targetRowWeight = totalWeight / targetRows;

        // simple row-packing to keep rectangle close to square
        const rows = [];
        let current = [];
        let currentWeight = 0;
        items.sort((a, b) => b.weight - a.weight).forEach((item, idx) => {
          const nextWeight = currentWeight + item.weight;
          const isLast = idx === items.length - 1;
          if (nextWeight > targetRowWeight && current.length) {
            rows.push({ items: current, weight: currentWeight });
            current = [item];
            currentWeight = item.weight;
          } else {
            current.push(item);
            currentWeight = nextWeight;
          }
          if (isLast) rows.push({ items: current, weight: currentWeight });
        });

        // compute available pixel height for rows (account for container padding and gap)
        const style = getComputedStyle(container);
        const gapPx = parseFloat(style.gap) || parseFloat(style.rowGap) || 0;
        const paddingTop = parseFloat(style.paddingTop) || 0;
        const paddingBottom = parseFloat(style.paddingBottom) || 0;
        const totalGap = Math.max(0, rows.length - 1) * gapPx;
        const availableHeight = Math.max(0, container.clientHeight - paddingTop - paddingBottom - totalGap);

        // assign pixel heights to rows so gaps/padding don't cause overflow
        let assigned = 0;
        rows.forEach((row, rIndex) => {
          const rowDiv = document.createElement("div");
          rowDiv.className = "treemap-row";
          if (availableHeight > 0) {
            // distribute available height proportionally, ensure a small minimum
            let rowHeightPx = Math.max(24, Math.round((row.weight / totalWeight) * availableHeight));
            // ensure last row fills remaining pixels to avoid rounding drift
            if (rIndex === rows.length - 1) rowHeightPx = Math.max(24, availableHeight - assigned);
            assigned += rowHeightPx;
            rowDiv.style.flex = `0 0 ${rowHeightPx}px`;
            rowDiv.style.height = `${rowHeightPx}px`;
          } else {
            // fallback to percent-based sizing when we can't measure container height yet
            const rowHeightPct = Math.max(8, (row.weight / totalWeight) * 100);
            rowDiv.style.flex = `0 0 ${rowHeightPct}%`;
          }

          row.items.forEach((f) => {
            const share = row.weight ? f.weight / row.weight : 0;
            const overallProgress = Math.max(0, Math.min(1, f.progress || 0));
            const milestoneProgress = milestone
              ? (() => {
                  const allocPct = getMilestonePercent(f, milestone.name);
                  const factor = allocPct / 100;
                  return factor > 0 ? Math.min(1, overallProgress / factor) : 0;
                })()
              : overallProgress;
            const milestoneStatus = (() => {
              if (f.status === "blocked") return "blocked";
              if (milestoneProgress >= 1) return "done";
              if (milestoneProgress > 0) return "in-progress";
              return "not-started";
            })();
            const item = document.createElement("div");
            item.className = `treemap-item status-${milestoneStatus || "not-started"}`;
            item.style.flex = `0 0 ${share * 100}%`;
            const baseColor = getStatusBaseColor(milestoneStatus);
            const bgColor = milestoneStatus === "in-progress" ? colorWithProgress(baseColor, milestoneProgress) : baseColor;
            item.style.background = bgColor;
            item.innerHTML = `
              <div>
                <h4>${localize(f, "name") || f.id}</h4>
                <div class="meta">${milestoneLabel(f.id, data.milestones)} &bull; ${f.size || "-"}</div>
                <div class="meta">${f.weight} pts (${(share * 100).toFixed(1)}% of row)</div>
              </div>
              <div class="meta">${(milestoneProgress * 100).toFixed(0)}% • ${milestoneStatus}</div>
              <div class="treemap-bar" style="width:${milestoneProgress * 100}%; background:${getProgressColor(milestoneStatus)}"></div>
            `;
            rowDiv.appendChild(item);
          });

          container.appendChild(rowDiv);
        });
      }

      function renderMilestones(data) {
        const container = document.getElementById("milestones");
        container.innerHTML = "";
        const defs = data.sizeDefinitions || {};
        const formatter = new Intl.NumberFormat(undefined, { style: "percent", minimumFractionDigits: 0, maximumFractionDigits: 0 });
        const featureMap = Object.fromEntries((data.features || []).map((f) => [f.id, f]));

        (data.milestones || []).forEach((m) => {
          let total = 0;
          let done = 0;
          (m.featuresIncluded || []).forEach((id) => {
            const f = featureMap[id];
            if (!f) return;
            const w = weightForSize(f.size, defs);
            const percent = getMilestonePercent(f, m.name);
            const factor = percent / 100;
            const progress = Math.max(0, Math.min(1, f.progress || 0));
            const normalized = factor > 0 ? Math.min(1, progress / factor) : 0;
            total += w * factor;
            done += w * factor * normalized;
          });
          const pct = total ? done / total : 0;

          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `
            <div class="row">
              <div>
                <div style="font-weight: 700;">${localize(m, "name")}</div>
                <div class="muted" style="font-size: 13px;">Target ${m.targetDate || "\u2014"}</div>
              </div>
              <div class="muted" style="font-weight: 600;">${formatter.format(pct)}</div>
            </div>
            <div class="progress-track" style="margin: 10px 0;">
              <div class="progress-bar" style="width:${pct * 100}%"></div>
            </div>
            <div class="muted" style="font-size: 13px;">${localize(m, "notes") || ""}</div>
          `;
          container.appendChild(card);
        });
      }

      function renderLegend(data) {
        const container = document.getElementById("legend");
        container.innerHTML = "";
        const statuses = data.legend?.status || {};
        Object.entries(statuses).forEach(([status, desc]) => {
          const item = document.createElement("div");
          item.className = "legend-item";
          item.innerHTML = `${renderStatusPill(status)}<span>${desc}</span>`;
          container.appendChild(item);
        });
      }

      function renderPieChart(data) {
        const container = document.getElementById("piechart");
        if (!container) return;
        container.innerHTML = "";

        const defs = data.sizeDefinitions || {};
        const milestone = viewFilter !== "all" ? (data.milestones || []).find((m) => m.name === viewFilter) : null;
        let items = (data.features || []).map((f) => ({ ...f, weight: weightForSize(f.size, defs) }));
        if (milestone) {
          const allowed = new Set(milestone?.featuresIncluded || []);
          items = items.filter((f) => allowed.has(f.id));
        }
        if (!items.length) return;

        // sort features so largest first (stable)
        items.sort((a, b) => b.weight - a.weight || (a.id > b.id ? 1 : -1));
        const total = items.reduce((acc, it) => acc + it.weight, 0) || 1;

        const rect = container.getBoundingClientRect();
        const side = Math.max(48, Math.min(rect.width, rect.height || rect.width));

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", side);
        svg.setAttribute("height", side);
        svg.setAttribute("viewBox", `0 0 ${side} ${side}`);
        const cx = side / 2;
        const cy = side / 2;
        const r = Math.floor(side / 2 * 0.9);

        function colorForIndex(i) {
          const hue = Math.round((i * 137.508) % 360);
          return `hsl(${hue} 70% 50%)`;
        }

        let startAngle = -Math.PI / 2;
        let aggTotal = 0;
        let aggDone = 0;
        items.forEach((it, idx) => {
          const angle = (it.weight / total) * Math.PI * 2;
          const endAngle = startAngle + angle;

          const overallProgress = Math.max(0, Math.min(1, it.progress || 0));
          const allocPct = milestone ? getMilestonePercent(it, milestone.name) : 100;
          const factor = allocPct / 100;
          const milestoneProgress = milestone
            ? factor > 0 ? Math.min(1, overallProgress / factor) : 0
            : overallProgress;

          aggTotal += it.weight * factor;
          aggDone += it.weight * factor * milestoneProgress;

          const ri = Math.max(0, Math.round(r * milestoneProgress));

          const large = angle > Math.PI ? 1 : 0;
          // draw background full-radius sector (represents undone portion)
          const bx1 = cx + r * Math.cos(startAngle);
          const by1 = cy + r * Math.sin(startAngle);
          const bx2 = cx + r * Math.cos(endAngle);
          const by2 = cy + r * Math.sin(endAngle);
          const bgPath = document.createElementNS(svgNS, "path");
          const dBg = [`M ${cx} ${cy}`, `L ${bx1} ${by1}`, `A ${r} ${r} 0 ${large} 1 ${bx2} ${by2}`, "Z"].join(" ");
          bgPath.setAttribute("d", dBg);
          bgPath.setAttribute("fill", "#e6eef9");
          bgPath.setAttribute("stroke", "#fff");
          bgPath.setAttribute("stroke-width", "0.6");
          svg.appendChild(bgPath);

          // draw colored sector representing completed progress (radius = ri)
          if (ri > 0) {
            const x1 = cx + ri * Math.cos(startAngle);
            const y1 = cy + ri * Math.sin(startAngle);
            const x2 = cx + ri * Math.cos(endAngle);
            const y2 = cy + ri * Math.sin(endAngle);
            const path = document.createElementNS(svgNS, "path");
            const d = [`M ${cx} ${cy}`, `L ${x1} ${y1}`, `A ${ri} ${ri} 0 ${large} 1 ${x2} ${y2}`, "Z"].join(" ");
            path.setAttribute("d", d);
            const col = colorForIndex(idx);
            path.setAttribute("fill", col);
            path.setAttribute("stroke", "#fff");
            path.setAttribute("stroke-width", "0.6");
            path.setAttribute("aria-label", `${it.name || it.id}: ${Math.round((it.weight/total)*100)}%`);
            path.setAttribute("title", `${it.name || it.id} — ${(it.weight/total*100).toFixed(1)}% — ${Math.round(milestoneProgress*100)}% progress`);
            svg.appendChild(path);
            // add sector label (positioned at mid-angle, radius ~50% of ri)
            try {
              const mid = (startAngle + endAngle) / 2;
              const progressPct = Math.round(milestoneProgress * 100);

              // inside label: progress percentage only
              if (ri > 12 && angle >= 0.08) {
                const labelRadius = Math.max(8, ri * 0.55);
                const lx = cx + labelRadius * Math.cos(mid);
                const ly = cy + labelRadius * Math.sin(mid);
                const fontSize = Math.max(7, Math.floor(side / 40));
                const estCharWidth = fontSize * 0.55;
                const estWidth = estCharWidth * `${progressPct}%`.length;
                const arcLen = Math.abs(angle) * labelRadius;
                if (estWidth + 4 <= arcLen) {
                  const lbl = document.createElementNS(svgNS, "text");
                  lbl.setAttribute("x", lx);
                  lbl.setAttribute("y", ly);
                  lbl.setAttribute("text-anchor", "middle");
                  lbl.setAttribute("font-size", fontSize);
                  lbl.setAttribute("fill", "#ffffff");
                  lbl.setAttribute("pointer-events", "none");
                  const t1 = document.createElementNS(svgNS, "tspan");
                  t1.setAttribute("x", lx);
                  t1.setAttribute("dy", Math.round(fontSize / 3));
                  t1.textContent = `${progressPct}%`;
                  lbl.appendChild(t1);
                  svg.appendChild(lbl);
                }
              }

              // outside label: feature name (and size) with connector line
              const nameText = localize(it, "name") || it.id;
              const sizeLabel = it.size ? ` (${it.size})` : "";
              const outerOffset = Math.max(12, Math.floor(side / 40));
              const outerR = r + outerOffset;
              const lxOut = cx + outerR * Math.cos(mid);
              const lyOut = cy + outerR * Math.sin(mid);
              const ex = cx + r * Math.cos(mid);
              const ey = cy + r * Math.sin(mid);

              const line = document.createElementNS(svgNS, "line");
              line.setAttribute("x1", ex);
              line.setAttribute("y1", ey);
              line.setAttribute("x2", lxOut);
              line.setAttribute("y2", lyOut);
              line.setAttribute("stroke", "#94a3b8");
              line.setAttribute("stroke-width", "1");
              line.setAttribute("stroke-linecap", "round");
              svg.appendChild(line);

              const lbl = document.createElementNS(svgNS, "text");
              const cosMid = Math.cos(mid);
              const anchor = cosMid >= 0 ? "start" : "end";
              lbl.setAttribute("text-anchor", anchor);
              const xPos = cosMid >= 0 ? lxOut + 6 : lxOut - 6;
              lbl.setAttribute("x", xPos);
              lbl.setAttribute("y", lyOut);
              const outerFontSize = Math.max(7, Math.floor(side / 50));
              lbl.setAttribute("font-size", outerFontSize);
              lbl.setAttribute("fill", "var(--text)");
              lbl.setAttribute("pointer-events", "none");
              lbl.setAttribute("dominant-baseline", "middle");
              const lineHeight = Math.round(outerFontSize * 1.1);

              const t1 = document.createElementNS(svgNS, "tspan");
              t1.setAttribute("x", xPos);
              t1.setAttribute("dy", -Math.round(sizeLabel ? lineHeight / 2 : 0));
              t1.textContent = nameText;
              lbl.appendChild(t1);

              if (sizeLabel) {
                const t2 = document.createElementNS(svgNS, "tspan");
                t2.setAttribute("x", xPos);
                t2.setAttribute("dy", lineHeight);
                t2.textContent = sizeLabel.trim();
                lbl.appendChild(t2);
              }
              svg.appendChild(lbl);
            } catch (err) {
              // ignore label placement errors
            }
          }
          startAngle = endAngle;
        });

        const aggPct = aggTotal ? Math.round((aggDone / aggTotal) * 100) : 0;
        const titleEl = document.getElementById("piechart-title");
        if (titleEl) {
          const baseTitle = milestone ? (localize(milestone, "name") || milestone.name) : t("piechartTitle");
          titleEl.textContent = `${baseTitle} · ${aggPct}%`;
        }

        container.appendChild(svg);

        // legend with progress (milestone-aware)
        const legend = document.createElement("div");
        legend.className = "treemap-legend";
        items.forEach((it, idx) => {
          const pct = Math.round((it.weight / total) * 100);
          const overallProgress = Math.max(0, Math.min(1, it.progress || 0));
          const milestoneProgress = milestone
            ? (() => {
                const allocPct = getMilestonePercent(it, milestone.name);
                const factor = allocPct / 100;
                return factor > 0 ? Math.min(1, overallProgress / factor) : 0;
              })()
            : overallProgress;

          const item = document.createElement("div");
          item.style.display = "flex";
          item.style.alignItems = "center";
          item.style.gap = "8px";
          item.style.marginRight = "8px";
          item.style.marginBottom = "6px";
          const colorBox = document.createElement("span");
          colorBox.style.width = "12px";
          colorBox.style.height = "12px";
          colorBox.style.background = colorForIndex(idx);
          colorBox.style.display = "inline-block";
          colorBox.style.borderRadius = "3px";
          const nameSpan = document.createElement("span");
          nameSpan.textContent = `${localize(it, "name") || it.id} ${pct}%`;
          nameSpan.style.fontSize = "13px";
          nameSpan.style.color = "var(--text)";
          const progressTrack = document.createElement("div");
          progressTrack.className = "progress-track";
          progressTrack.style.width = "120px";
          progressTrack.style.height = "8px";
          progressTrack.style.marginLeft = "8px";
          progressTrack.style.background = "var(--pill)";
          const progressBar = document.createElement("div");
          progressBar.className = "progress-bar";
          progressBar.style.width = `${Math.round(milestoneProgress*100)}%`;
          progressBar.style.background = colorForIndex(idx);
          progressTrack.appendChild(progressBar);

          item.appendChild(colorBox);
          item.appendChild(nameSpan);
          item.appendChild(progressTrack);
          legend.appendChild(item);
        });
        container.appendChild(legend);
      }

  function renderStatusPill(status) {
    const safeStatus = status || "not-started";
    return `<span class="pill status-${safeStatus}"><span class="dot"></span>${safeStatus.replace("-", " ")}</span>`;
  }

  function localize(item, field) {
    if (currentLanguage !== "en" && item?.translations?.[currentLanguage]?.[field]) {
      return item.translations[currentLanguage][field];
    }
    return item?.[field] || "";
  }

  function milestoneLabel(featureId, milestones) {
    if (!milestones || !featureId) return "\u2014";
    const names = milestones
      .filter((m) => (m.featuresIncluded || []).includes(featureId))
      .map((m) => localize(m, "name"));
    return names.length ? names.join(" / ") : "\u2014";
  }

      function render(data) {
        renderTabs(data);
        renderSummary(data);
        renderFeaturesTable(data);
        renderPieChart(data);
        renderTreemap(data);
        renderMilestones(data);
        renderLegend(data);
        renderEditor(data);
        updateMilestoneProgressHeaders(data.milestones || []);
      }

      function applyStaticTranslations() {
        document.getElementById("title-main").textContent = t("title");
        document.getElementById("milestones-title").textContent = t("milestonesTitle");
        document.getElementById("milestones-sub").textContent = t("milestonesSub");
        document.getElementById("features-title").textContent = t("featuresTitle");
        document.getElementById("treemap-title").textContent = t("treemapTitle");
        document.getElementById("treemap-sub").textContent = t("treemapSub");
        const pieTitleEl = document.getElementById("piechart-title");
        if (pieTitleEl) pieTitleEl.textContent = t("piechartTitle");
        const pieSubEl = document.getElementById("piechart-sub");
        if (pieSubEl) pieSubEl.textContent = t("piechartSub");
        const legendTitleEl = document.getElementById("legend-title");
        if (legendTitleEl) legendTitleEl.textContent = t("legendTitle");
        document.getElementById("inline-title").textContent = t("inlineTitle");
        document.getElementById("inline-note").textContent = t("inlineNote");
        document.getElementById("inline-footnote").textContent = t("inlineFootnote");
        document.getElementById("th-feature").textContent = t("columns")["feature"];
        const milestoneHeader = document.getElementById("th-milestone");
        if (milestoneHeader) milestoneHeader.textContent = t("columns")["milestone"];
        document.getElementById("th-milestone-progress-1").textContent = t("columns")["milestoneProgress1"];
        document.getElementById("th-milestone-progress-2").textContent = t("columns")["milestoneProgress2"];
        document.getElementById("th-status").textContent = t("columns")["status"];
        document.getElementById("th-size").textContent = t("columns")["size"];
        document.getElementById("th-progress").textContent = t("columns")["progress"];
        document.getElementById("th-eta").textContent = t("columns")["eta"];
        document.getElementById("btn-edit").textContent = t("buttons")["edit"];
        document.getElementById("btn-close-edit").textContent = t("buttons")["close"];
        document.getElementById("btn-download").textContent = t("buttons")["download"];
        document.getElementById("btn-upload").textContent = t("buttons")["upload"];
        document.getElementById("btn-reset").textContent = t("buttons")["reset"];
      }

      function t(key) {
        return translations[currentLanguage]?.[key] || key;
      }

      function setLanguage(lang, rerender = true) {
        currentLanguage = translations[lang] ? lang : 'en';
        document.getElementById("btn-lang-en").classList.toggle("active", currentLanguage === "en");
        document.getElementById("btn-lang-vi").classList.toggle("active", currentLanguage === "vi");
        applyStaticTranslations();
        if (rerender && stateData) render(stateData);
      }

      function renderEditor(data) {
        const editor = document.getElementById("editor");
        const grid = document.getElementById("editor-grid");
        if (!editing) {
          editor.hidden = true;
          return;
        }
        editor.hidden = false;
        grid.innerHTML = "";
        const statusOptions = ["not-started", "in-progress", "blocked", "done"];
        const sizeOptions = Object.keys(data.sizeDefinitions || {});
        const milestones = data.milestones || [];

        (data.features || []).forEach((f, index) => {
          const card = document.createElement("div");
          card.className = "editor-card";
          const featureMilestones = milestones.map((m) => ({
            name: localize(m, "name") || m.name || "",
            checked: (m.featuresIncluded || []).includes(f.id),
            key: m.name,
            percent: getMilestonePercent(f, m.name),
          }));
          card.innerHTML = `
            <div class="row" style="align-items: center; justify-content: space-between;">
              <div style="font-weight: 700;">${localize(f, "name") || f.id}</div>
              <div class="move-buttons">
                <button type="button" class="icon-btn" data-move="up" data-index="${index}" ${index === 0 ? "disabled" : ""}>Up</button>
                <button type="button" class="icon-btn" data-move="down" data-index="${index}" ${index === (data.features?.length || 0) - 1 ? "disabled" : ""}>Down</button>
              </div>
            </div>
            <div>
              <label>Name</label>
              <input type="text" value="${f.name || ""}" data-id="${f.id}" data-field="name" />
            </div>
            <div>
              <label>Status</label>
              <select data-id="${f.id}" data-field="status">
                ${statusOptions
                  .map((s) => `<option value="${s}" ${s === f.status ? "selected" : ""}>${s}</option>`)
                  .join("")}
              </select>
            </div>
            <div>
              <label>Size</label>
              <select data-id="${f.id}" data-field="size">
                ${sizeOptions
                  .map((s) => `<option value="${s}" ${s === f.size ? "selected" : ""}>${s}</option>`)
                  .join("")}
              </select>
            </div>
            <div>
              <label data-progress-label="${f.id}">${t("progressLabel")} (${Math.round((f.progress || 0) * 100)}%)</label>
              <input type="range" min="0" max="100" step="1" value="${Math.round((f.progress || 0) * 100)}" data-id="${f.id}" data-field="progress" />
            </div>
            <div>
              <label>${t("columns")["eta"]}</label>
              <input type="date" value="${f.eta || ""}" data-id="${f.id}" data-field="eta" />
            </div>
            <div>
              <label>Notes</label>
              <textarea data-id="${f.id}" data-field="notes">${f.notes || ""}</textarea>
            </div>
            <div>
              <label>Milestones</label>
              <div class="feature-milestones">
                ${
                  featureMilestones.length
                    ? featureMilestones
                        .map(
                          (m, mIndex) => `
                            <label>
                              <input type="checkbox" data-scope="feature-milestone" data-feature="${f.id}" data-milestone-index="${mIndex}" data-milestone-name="${m.key}" ${m.checked ? "checked" : ""} />
                              ${m.name}
                              <input type="number" min="0" max="100" value="${m.percent}" data-scope="feature-milestone-percent" data-feature="${f.id}" data-milestone-name="${m.key}" ${m.checked ? "" : "disabled"} style="width: 72px;" aria-label="Percent allocation for ${m.name}" />
                              <span class="muted" style="font-size: 12px;">%</span>
                            </label>
                          `
                        )
                        .join("")
                    : `<div class="small">No milestones defined.</div>`
                }
              </div>
            </div>
          `;
          grid.appendChild(card);
        });

        grid.querySelectorAll("input, select, textarea").forEach((el) => {
          el.oninput = handleEditChange;
          el.onchange = handleEditChange;
        });
        grid.querySelectorAll("[data-move]").forEach((btn) => {
          btn.onclick = () => {
            const idx = Number(btn.getAttribute("data-index"));
            const direction = btn.getAttribute("data-move") === "up" ? -1 : 1;
            moveFeature(idx, direction);
          };
        });
        grid.querySelectorAll('[data-scope="feature-milestone"]').forEach((el) => {
          el.onchange = handleFeatureMilestoneToggle;
        });
        grid.querySelectorAll('[data-scope="feature-milestone-percent"]').forEach((el) => {
          el.oninput = handleMilestonePercentChange;
          el.onchange = handleMilestonePercentChange;
        });
      }

      function handleEditChange(e) {
        const id = e.target.getAttribute("data-id");
        const field = e.target.getAttribute("data-field");
        if (!id || !field) return;
        const feature = (stateData.features || []).find((f) => f.id === id);
        if (!feature) return;
        let value = e.target.value;
        if (field === "progress") {
          value = Math.min(100, Math.max(0, Number(value))) / 100;
          const label = e.target.parentElement?.querySelector(`[data-progress-label="${id}"]`);
          if (label) label.textContent = `${t("progressLabel")} (${Math.round(value * 100)}%)`;
          const statusSelect = e.target.parentElement?.parentElement?.querySelector('select[data-field="status"]');
          if (value >= 1) {
            feature.status = "done";
            if (statusSelect) statusSelect.value = "done";
          } else if (value === 0) {
            if (feature.status !== "blocked") {
              feature.status = "not-started";
              if (statusSelect) statusSelect.value = "not-started";
            }
          } else if (feature.status === "done" || feature.status === "not-started") {
            feature.status = "in-progress";
            if (statusSelect) statusSelect.value = "in-progress";
          }
        }
        if (field === "status") {
          if (value === "done") {
            feature.progress = 1;
            const range = e.target.parentElement?.parentElement?.querySelector('input[data-field="progress"]');
            if (range) {
              range.value = 100;
              const label = e.target.parentElement?.parentElement?.querySelector(`[data-progress-label="${id}"]`);
              if (label) label.textContent = `${t("progressLabel")} (100%)`;
            }
          } else if (value === "not-started" && feature.progress > 0) {
            value = "in-progress";
            e.target.value = "in-progress";
          } else if (value === "blocked" && feature.progress > 0) {
            feature.progress = 0;
            const range = e.target.parentElement?.parentElement?.querySelector('input[data-field="progress"]');
            if (range) {
              range.value = 0;
              const label = e.target.parentElement?.parentElement?.querySelector(`[data-progress-label="${id}"]`);
              if (label) label.textContent = `${t("progressLabel")} (0%)`;
            }
          }
        }
        feature[field] = value;
        markDirty();
        renderSummary(stateData);
        renderFeaturesTable(stateData);
        renderTreemap(stateData);
        renderMilestones(stateData);
      }

      function handleFeatureMilestoneToggle(e) {
        const featureId = e.target.getAttribute("data-feature");
        const milestoneIndex = Number(e.target.getAttribute("data-milestone-index"));
        const milestoneName = e.target.getAttribute("data-milestone-name");
        if (!featureId || Number.isNaN(milestoneIndex)) return;
        const milestone = (stateData.milestones || [])[milestoneIndex];
        if (!milestone || milestone.name !== milestoneName) return;
        const feature = (stateData.features || []).find((f) => f.id === featureId);
        if (!feature) return;
        if (!feature.milestoneAllocations) feature.milestoneAllocations = {};
        const current = new Set(milestone.featuresIncluded || []);
        if (e.target.checked) {
          current.add(featureId);
          if (feature.milestoneAllocations[milestoneName] === undefined) feature.milestoneAllocations[milestoneName] = 100;
          const percentInput = e.target.parentElement?.querySelector('[data-scope="feature-milestone-percent"]');
          if (percentInput) percentInput.disabled = false;
        } else {
          current.delete(featureId);
          delete feature.milestoneAllocations[milestoneName];
          const percentInput = e.target.parentElement?.querySelector('[data-scope="feature-milestone-percent"]');
          if (percentInput) percentInput.disabled = true;
        }
        milestone.featuresIncluded = Array.from(current);
        markDirty();
        renderFeaturesTable(stateData);
        renderTreemap(stateData);
        renderMilestones(stateData);
      }

      function handleMilestonePercentChange(e) {
        const featureId = e.target.getAttribute("data-feature");
        const milestoneName = e.target.getAttribute("data-milestone-name");
        if (!featureId || !milestoneName) return;
        const feature = (stateData.features || []).find((f) => f.id === featureId);
        if (!feature) return;
        if (!feature.milestoneAllocations) feature.milestoneAllocations = {};
        const next = Math.max(0, Math.min(100, Number(e.target.value)));
        feature.milestoneAllocations[milestoneName] = Number.isFinite(next) ? next : 100;
        e.target.value = feature.milestoneAllocations[milestoneName];
        markDirty();
        renderMilestones(stateData);
      }

      function moveFeature(index, direction) {
        const features = stateData.features || [];
        const targetIndex = index + direction;
        if (targetIndex < 0 || targetIndex >= features.length) return;
        const [removed] = features.splice(index, 1);
        features.splice(targetIndex, 0, removed);
        markDirty();
        render(stateData);
      }

      function enableEditing() {
        editing = true;
        document.getElementById("btn-edit").disabled = true;
        document.getElementById("btn-close-edit").disabled = false;
        document.getElementById("btn-download").disabled = false;
        document.getElementById("btn-reset").disabled = false;
        renderEditor(stateData);
      }

      function closeEditing() {
        editing = false;
        document.getElementById("editor").hidden = true;
        document.getElementById("btn-edit").disabled = false;
        document.getElementById("btn-close-edit").disabled = true;
      }

      function downloadJson() {
        const blob = new Blob([JSON.stringify(stateData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "state.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function uploadJson(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const parsed = JSON.parse(event.target?.result || "{}");
            stateData = parsed;
            originalData = JSON.parse(JSON.stringify(parsed));
            ensureMilestoneAllocations(stateData);
            editing = true;
            document.getElementById("btn-edit").disabled = true;
            document.getElementById("btn-download").disabled = false;
            document.getElementById("btn-reset").disabled = false;
            render(stateData);
            saveLocalState(stateData);
          } catch (err) {
            document.getElementById("error").textContent = "Invalid JSON file.";
          }
        };
        reader.readAsText(file);
      }

      function resetData() {
        stateData = JSON.parse(JSON.stringify(originalData));
        ensureMilestoneAllocations(stateData);
        render(stateData);
        document.getElementById("btn-download").disabled = true;
        document.getElementById("btn-reset").disabled = true;
        document.getElementById("btn-edit").disabled = false;
        document.getElementById("btn-close-edit").disabled = true;
        editing = false;
        document.getElementById("editor").hidden = true;
        clearLocalState();
      }

      function saveLocalState(data) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch (err) {
          console.warn("Failed to save state locally", err);
        }
      }

      function loadCachedState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch (err) {
          console.warn("Failed to read cached state", err);
          return null;
        }
      }

      function clearLocalState() {
        try {
          localStorage.removeItem(STORAGE_KEY);
        } catch (err) {
          console.warn("Failed to clear cached state", err);
        }
      }

      function removeLegacyFields(data) {
        if (data?.legend && data.legend.size) {
          delete data.legend.size;
        }
      }

      function ensureMilestoneAllocations(data) {
        const milestones = data?.milestones || [];
        const milestoneNames = new Set(milestones.map((m) => m.name));
        (data.features || []).forEach((f) => {
          if (!f.milestoneAllocations || typeof f.milestoneAllocations !== "object") {
            f.milestoneAllocations = {};
          }
          milestones.forEach((m) => {
            if ((m.featuresIncluded || []).includes(f.id) && f.milestoneAllocations[m.name] === undefined) {
              f.milestoneAllocations[m.name] = 100;
            }
            if (!(m.featuresIncluded || []).includes(f.id) && f.milestoneAllocations[m.name] !== undefined) {
              delete f.milestoneAllocations[m.name];
            }
          });
          Object.keys(f.milestoneAllocations).forEach((k) => {
            if (!milestoneNames.has(k)) delete f.milestoneAllocations[k];
          });
        });
      }

      function setupActions() {
        document.getElementById("btn-edit").onclick = enableEditing;
        document.getElementById("btn-close-edit").onclick = closeEditing;
        document.getElementById("btn-download").onclick = downloadJson;
        document.getElementById("btn-reset").onclick = resetData;
        document.getElementById("btn-upload").onclick = () => document.getElementById("file-input").click();
        document.getElementById("file-input").onchange = (e) => {
          const file = e.target.files?.[0];
          if (file) uploadJson(file);
          e.target.value = "";
        };
        document.getElementById("btn-lang-en").onclick = () => setLanguage("en");
        document.getElementById("btn-lang-vi").onclick = () => setLanguage("vi");
      }

      function getStatusBaseColor(status) {
        switch (status) {
          case "done":
            return "#10b981"; // green
          case "blocked":
            return "#fbbf24"; // brighter yellow for blocked
          case "in-progress":
            return "#ef4444"; // red for in-progress
          case "not-started":
            return "transparent"; // no fill for not started
          default:
            return "transparent"; // no fill fallback
        }
      }

      function colorWithProgress(hex, progress) {
        const { r, g, b } = hexToRgb(hex);
        const clamped = Math.max(0, Math.min(1, progress || 0));
        return `rgba(${r}, ${g}, ${b}, ${clamped.toFixed(2)})`;
      }

      function hexToRgb(hex) {
        const clean = hex.replace("#", "");
        const normalized = clean.length === 3
          ? clean.split("").map((c) => c + c).join("")
          : clean.padEnd(6, "0");
        const intVal = parseInt(normalized, 16);
        return {
          r: (intVal >> 16) & 255,
          g: (intVal >> 8) & 255,
          b: intVal & 255,
        };
      }

      function getProgressColor(status) {
        return "var(--blue)";
      }

      loadState();
      // recompute treemap and piechart layout when window resizes so pixel heights stay accurate
      window.addEventListener("resize", () => {
        try {
          if (stateData) {
            renderTreemap(stateData);
            renderPieChart(stateData);
          }
        } catch (err) {
          // no-op
        }
      });
    </script>
  </body>
</html>
